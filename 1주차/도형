알고리즘 스터디 p1-81 / p415-464

p417-433

-지수 표현 방식 e,E : 1e9 => 1*10**9
-컴퓨터는 실수를 제대로 표현 x -> round 함수(실수형, 반올림 위치 -1) *코테에서는 소수점 5자리까지 (실수형, 4)
- / 는 실수처리
- list : list() or []로 초기화 / 크기가 n 인 리스트 초기화 -> n=10, a = [0] * 10, print(a) -> [0,0,0,...0]
-리스트 인덱싱, 슬라이싱 
-append(x) : 인덱스 마지막에 x 추가
-리스트 컴프리헨션 : 2차원리스트 초기화 n=3, m=4 array = [[0]*m for _ in range[n]] >>>> [[0,0,0,0], [0,0,0,0],[0,0,0,0]] '_': 단순 반복일 때
-insert()vs append() : insert O(n) vs append O(1)
-not in~ : ~에 없는 것을 선택 
-\ : 작은 따옴표 포함
-문자열은 내부적으로 리스트와 같이 처리. > 인덱싱 가능
-튜플 : 값 변경 불가
-사전자료형 : key-value  dict()
-집합자료표현 : 초기화 1) set() 2) {, , , } / (합집합 |) (교집합 &) (차집합 -) / add() : 한개 update() : 여러개

p1-54
-언어 선택 
 파이썬 vs c++ 
 c/c++은 실행 시간에서 우위, 좀 더 하드웨어에 적합
 프로그램 개발 방식 코테에서는 파이썬이 우위(라이브러리)

-온라인 개발 환경
 리플릿 

-오프라인 개발 환경 
파이참

[3] 복잡도
-시간 복잡도 : 시간(연산 횟수)
-공간 복잡도 : 메모리

-시간 복잡도 
 대입과 출력은 n이 커질수록 무시가능 > 연산만 집중 
 >> 코테는 최악의 경우를 고려해야함
  ex) 일반적으로 시간제한이 1초일때 n의 범위에 따라 설계 방향이 달라짐
  -n 500 : O(n***3)
  -n 2000 : O(n**2)
  -n 100000 : O(nlogn)
  -n 10000000 : O(n)

-공간 복잡도 
 
-시간과 메모리 측정 
import time
start_time = time.time()
…
end_time = time.time()
print(“time : “, end_time - start_time)
