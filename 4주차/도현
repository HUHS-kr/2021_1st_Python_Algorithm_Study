
자료구조 스택
선입후출, 후입선출이라고 불린다. 단순하게 생각해서 쌓는다고 생각하면 된다.
파이썬에서 스택을 사용할 때는 별도의 라이브러리 없이 그냥 리스트를 사용하면 된다.
append 메서드와 pop메서드는 스택의 push 와 pop으로 동작한다.

자료구조 큐
선입선출, 후입후출이라고 불린다. 이는 구멍이 두개있고 한 구멍으로 넣으면 반대쪽 구멍에서 뺀다고 생각하면 된다.
파이썬에서 큐를 사용할때는 from collections import deque를 사용해야한다.
이를 통해 queue = deque()로 자료구조 큐를 만들고 사용하면 된다.
append 메서드와 popleft메서드를 통해 push와 pop을 나타낼 수 있다.

프로그래밍에서는 그래프를 크게 2가지 방식으로 표현한다.
1. 인접 행렬(Adjacency Matrix): 2차원 배열로 그래프의 연결 관계를 표현하는 방식
2. 인접 리스트(Adjacency List): 리스트로 그래프의 연결 관계를 표현하는 방식

먼저 인접행렬 방식은 2차원 행렬로 서로간의 거리를 표현한다. 서로 연결되지 않는 노드끼리는 무한의 거리가 있다고 작성한다.
graph = [
    [0,7,5]
    [7,0,INF]
    [5,INF,0]
]
처럼 표현한다. 이는 모든 관계를 다 표현하는 것이 특징이다.

인접리스트 방식은 연결 리스트라는 자료구조를 이용해서 연결된 노드정보만을 저장한다.
graph = [[] for _ in range(3)]
graph[0].append((1,7)) // 0은 1과 7만큼의 거리(간선)로 연결되어있다.
graph[0].append((2,5)) // 0은 2와 5만큼의 거리(간선)로 연결되어있다.
graph[1].append((0,7)) // 1은 0과 7만큼의 거리(간선)로 연결되어있다.
// 1과 2는 연결되어있지 않으므로 표현하지 않는다.
graph[2].append((0,5)) // 2는 0과 5만큼의 거리(간선)로 연결되어있다.
// 2와 1은 연결되어있지 않으므로 표현하지 않는다.

인접행렬방식은 모든 관계를 저장하므로, 노드의 개수가 많을수록 메모리가 불필요하게 낭비된다.
반면에 인접 리스트 방식은 연결된 정보만을 저장하기 때문에 메모리를 효율적으로 관리한다.
하지만 노드의 연결성을 확인하기 위해서 인접 행렬 방식은 그냥 graph[0][1]을하면 0과 1이 연결되어있는지 확인할 수 있는데,
인접 리스트 방식에서는 graph[0]을 다 둘러봐야지 1이 있는지 없는지 확인해낼 수 있다.
따라서 하나만 확인하면 되는것은 행렬방식이, 어차피 모두 둘러봐야하는 것은 리스트 방식이 유리하다.

DFS 는 Depth-First Search로 깊이 우선 탐색이라고 부른다.
DFS는 스택자료구조를 이용하며, 다음과 같이 동작한다.
1. 탐색 시작 노드를 스택에 삽입하고 방문처리한다.
2. 스택의 최상단 노드에 방문하지 않은 인접노드가 있으면 그 인접노드를 스택에 넣고 방문처리한다.
이때 방문하지 않은 인접노드가 없으면 스택에서 최상단 노드를 꺼낸다.
3. 2번의 과정을 더 이상 수행할 수 없을 때까지 반복한다.

간단하게 생각하면, 하나의 노드1을 잡아서 스택에 넣고, 그 노드1의 인접 노드2를 넣고,
이제 노드2가 스택의 최상단이니 노드2의 인접노드3을 잡아서 넣고, 만약에 노드3을 넣었는데 노드3이 노드2말고는 친구가 없으면
노드3을 스택에서 빼내고, 다음최상단인 노드2를 통해 3말고 다른 친구를 찾게 된다.
그러면 결국 왔다갔다하면서 모든 노드를 탐색하게 된다.

DFS는 데이터개수가 N개인 경우 O(N)의 시간이 소요된다는 특징이 있다.
모두 탐색해야하니 인접 리스트를 사용해서 구현한다.

def dfs(graph, v, visited):
      visited[v] = True // 현재 노드 방문처리
      print(v, end = ' ')
      for i in graph[v]:
          if not visited[i]:
              dfs(graph, i, visited)
              
graph = [
    [],
    [2,3,8],
    [1,7],
    [1,4,5],
    [3,5],
    [3,4],
    [7],
    [2,6,8],
    [1,7]
]

visited = [False] * 9

처럼 사용하면 된다.
