정렬: 데이터를 기준에 따라 순서대로 나열
-> 상황에 따라 적절한 정렬 알고리즘을 사용하는 것이 중요!!

p.156 카드 예제 기준 >>

*선택 정렬(Selection sort): 가장 작은 것만 선택해서 맨 앞으로 보내는 알고리즘. 
 -> swap 코드로 원소 위치 변경
  시간 복잡도는 O(N^2) 이므로 비효율적임.
  
*삽입 정렬(Insert sort): 데이터를 하나씩 확인하며 적절한 위치에 삽입하는 알고리즘. 이때 그 앞까지 데이터는 정렬되어 있다고 가정.
 시간 복잡도는 O(N^2) 이지만 데이터가 거의 정렬되어 있으면 매우 효율적임.
  
*퀵 정렬(Quick sort): 기준 데이터를 설정하고 그것보다 큰 데이터와 작은 데이터의 위치를 바꾸는 알고리즘. pivot 이 사용됨.
 pivot 설정, 큰 데이터와 작은 데이터 위치 변경을 반복하며 현재 리스트의 데이터 개수가 1일때까지 수행.
 시간 복잡도는 O(NlogN) 이므로 빠름. 
 
*계수 정렬(Count sort): 데이터 크기 범위가 제한되어 정수로 표현 가능할 때만 사용할 수 있지만, 매우 빠른 알고리즘.
 별도의 리스트 선언 후, 데이터 값과 동일한 인덱스 데이터를 1씩 증가시켜 완료함.
 시간 복잡도는 O(N+K) 이므로 매우 빠름. 공간 복잡도도 O(N+K) 이므로 특정 상황에서만 사용할 것.
 
 
 
 
[문제 풀이]
#1 국영수
1. 리스트 선언 
2. 학생 정보 입력
3. 영어 점수 내림차순 정렬
3-1. 영어가 같은 경우, 수학 점수 오름차순 정렬
3-2. 수학이 같은 경우, 이름 내림차순 정렬
3-3. 이름이 같은 경우, 국어 점수 오름차순 정렬
4. 정렬된 데이터에서 이름만 출력

#2 안테나
1. 리스트 선언
2. 집 위치 정보 입력
3. 오름차순으로 정렬
4. 중간값 출력

#3 실패율
1. solution 함수를 정의
2. 스테이지 번호를 증가시키며 해댱 스테이지에 있는 사람 수 계산
3. 실패율 계산
4. 리스트에 스테이지 번호와 실패율 삽입
5. 각 스테이지 실패율 내림차순 정렬
6. 스테이지 번호 출력

#4 카드 정렬하기
1. import headq
2. n 입력 후 heap 에 카드 묶음 모두 삽입
3. heap 에 원소 1개 남을 때까지 가장 작은 2개의 묶음 꺼내기
4. 묶음 합쳐서 다시 삽입
5. 결과 출력
 
 
