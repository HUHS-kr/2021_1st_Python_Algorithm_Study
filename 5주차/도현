선택 정렬, 삽입 정렬, 퀵 정렬, 계수 정렬에 대해 배워보자.

선택정렬
가장 원시적인 방법으로 오름차순 기준 가장 작은 것을 선택한다는 의미이다.
(내림차순 기준으로는 가장 큰 것을 선택한다는 의미이다.)
가장 작은 것을 선택해서 앞으로 보내는 과정을 반복적으로 수행한다면, 전체 데이터의 정렬이 이루어진다.
다시말해 중첩 for 문을 통해 i에서는 실제 설정할 인덱스를 선택하고 j에서는 그보다 큰 인덱스 중에서 가장 작은 값의 인덱스를 찾은 다음에 그것을 min에 넣어서 최신화 시켜준다.
그렇게 나온 min의 값은 i번째 인덱스에 들어가게 된다.
파이썬 구현은 다음과 같다.

array = [7,1,2,5,1,7,4]

for i in range(len(array)):
    min_index = i // 일단 아무거나 넣자
    for j in range(i+1, len(array)):
        if(array[min_index] > array[j]):
            min_index = j //만약 min으로 해둔것보다 더 작은게 있으면 그걸 min으로 바꿔줄게.
    array[i], array[min_index] = array[min_index], array[i] // 실제 인덱스에 결국 선정된 min값을 넣어준다.
   
선택정렬의 시간복잡도는 데이터 array값을 두번 반복해서 돌아다니므로 O(N^2)의 시간복잡도를 가진다.
이는 비효율적인 정렬과정이라고 생각할 수 있지만 익숙해질 필요가 있다.

삽입정렬
데이터를 하나씩 확인하면서, 각 데이터를 적절한 위치에 삽입하는 방법
삽입정렬은 데이터가 거의 정렬되어 있을 때 훨씬 효율적인 방법이다.
선택정렬과 비교하면 선택정렬은 현재 데이터의 상태와 상관없이 무조건 모든 데이터를 확인한다.
삽입정렬은 두번째 데이터부터 넣게된다. 들어가 있는 첫번째 데이터를 기준으로 두번째 데이터가 어디에 들어갈 지 확인하고 넣는 방식이다.
이 방식의 장점은 모두를 살펴볼 필요없이, 자기 자신보다 작거나 큰 데이터 옆에 붙으면 되는 것이다.
예를들어서 1,3,5,7,9에서 오름차순 정렬일때 4를 넣어야한다. 이때 이는 다른거 볼 필요없이 자기보다 작은 것 중에 제일 큰 3옆에 붙으면 된다.
이를 코드로 구현하면 그냥 반대방향부터 가면서 자기보다 작은것을 만나면 그보다 오른쪽에 붙이면 되는 것이다.
array = [7,1,2,5,1,7,4]

for i in range(1, len(array)):
    for j in range(i, 0, -1):
        if(array[j] < array[j-1]):
            array[j], array[j-1] = array[j-1], array[j]
        else:
            break
            
삽입정렬은 시간복잡도는 O(N^2)으로 선택정렬과 같지만 break문이 존재한다는 점에서 선택정렬보다 빠르게 동작한다. 최대 O(N)까지 기대된다.

퀵정렬
정렬 알고리즘 중에 가장 많이 사용되는 알고리즘이다.
기준데이터를 설정하고 그 기준보다 큰 데이터와 작은 데이터의 위치를 바꾸는 방식으로 작동한다.
이때 기준을 정해야하는데 책에서는 호어 분할 방식을 기준으로 설명한다.
호어분할 방식은 리스트에서 첫 번째 데이터를 피벗(기준)으로 설정한다.
이렇게 피벗을 설정한 다음에 오름차순 기준으로 왼쪽에서(피벗보다 왼쪽이 아니라 그냥 배열상 제일 왼쪽) 피벗보다 큰 데이터를 찾고, 오른쪽에서 피벗보다 작은 데이터를 찾아서 둘을 교환해준다.
이때 왼쪽에서 시작한 데이터와 오른쪽에서 시작한 데이터가 엇갈려서 서로 오른쪽 왼쪽이 바뀔 때는 찾아진 작은데이터를 피벗인 값과 위치를 바꾼다.
지금 방법까지 완료하면 원래 피벗이 교환되어서 들어간 자리 오른쪽에는 원래 피벗보다 큰수가, 왼쪽에는 작은수가 들어가 있다.
이 상태에서 왼쪽과 오른쪽을 개별적으로 피벗을 활용해서 정리하고, 이를 반복하면 결과적으로 배열이 정리가 된다.
이를 기본적인 소스코드로 살펴보면 이해가 쉽다.

array = [5, 7, 9, 0, 3, 1, 6, 2, 4, 8]

def quick_sort(array, start, end):
        if(start >= end):
            return
        pivot = start
        left = start + 1
        right = end
        while(left <= right):
            while(left <= end and array[left] <= array[pivot]):
                left += 1
            while(right >= start and array[right] >= array[pivot]):
                right -= 1
            if( left > right ):
                array[right], array[pivot] = array[pivot], array[right]
            else:
                array[left], array[right] = arrya[right], array[left]
        quick_sort(array, start, right-1)
        quick_sort(array, right+1, end)
        
처럼 구현하면 된다. 이처럼 사람 머리로 쉽게 정리가 안되는 것이더라도 컴퓨터 알고리즘으로 풀어쓰면 쉬워보이는 코드가 많다.
그래서 알고리즘을 더 공부해야하는 한다고 생각한다.

퀵 정렬의 시간복잡도는 평균 O(NlogN)이며, 최대 O(N^2) 이다.
퀵 정렬의 데이터는 데이터가 잘 정리되어있으면 더욱 느리다. 따라서 삽입정렬 알고리즘과 선택적으로 사용해야한다.
하지만 라이브러리를 사용하면 퀵정렬을 평균 NlogN을 보장해주도록 추가적인 설정을 도와준다.
