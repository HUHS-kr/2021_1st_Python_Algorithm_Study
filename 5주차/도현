선택 정렬, 삽입 정렬, 퀵 정렬, 계수 정렬에 대해 배워보자.

선택정렬
가장 원시적인 방법으로 오름차순 기준 가장 작은 것을 선택한다는 의미이다.
(내림차순 기준으로는 가장 큰 것을 선택한다는 의미이다.)
가장 작은 것을 선택해서 앞으로 보내는 과정을 반복적으로 수행한다면, 전체 데이터의 정렬이 이루어진다.
다시말해 중첩 for 문을 통해 i에서는 실제 설정할 인덱스를 선택하고 j에서는 그보다 큰 인덱스 중에서 가장 작은 값의 인덱스를 찾은 다음에 그것을 min에 넣어서 최신화 시켜준다.
그렇게 나온 min의 값은 i번째 인덱스에 들어가게 된다.
파이썬 구현은 다음과 같다.

array = [7,1,2,5,1,7,4]

for i in range(len(array)):
    min_index = i // 일단 아무거나 넣자
    for j in range(i+1, len(array)):
        if(array[min_index] > array[j]):
            min_index = j //만약 min으로 해둔것보다 더 작은게 있으면 그걸 min으로 바꿔줄게.
    array[i], array[min_index] = array[min_index], array[i] // 실제 인덱스에 결국 선정된 min값을 넣어준다.
   
선택정렬의 시간복잡도는 데이터 array값을 두번 반복해서 돌아다니므로 O(N^2)의 시간복잡도를 가진다.
이는 비효율적인 정렬과정이라고 생각할 수 있지만 익숙해질 필요가 있다.

삽입정렬
데이터를 하나씩 확인하면서, 각 데이터를 적절한 위치에 삽입하는 방법
삽입정렬은 데이터가 거의 정렬되어 있을 때 훨씬 효율적인 방법이다.
선택정렬과 비교하면 선택정렬은 현재 데이터의 상태와 상관없이 무조건 모든 데이터를 확인한다.
삽입정렬은 두번째 데이터부터 넣게된다. 들어가 있는 첫번째 데이터를 기준으로 두번째 데이터가 어디에 들어갈 지 확인하고 넣는 방식이다.
이 방식의 장점은 모두를 살펴볼 필요없이, 자기 자신보다 작거나 큰 데이터 옆에 붙으면 되는 것이다.
예를들어서 1,3,5,7,9에서 오름차순 정렬일때 4를 넣어야한다. 이때 이는 다른거 볼 필요없이 자기보다 작은 것 중에 제일 큰 3옆에 붙으면 된다.
이를 코드로 구현하면 그냥 반대방향부터 가면서 자기보다 작은것을 만나면 그보다 오른쪽에 붙이면 되는 것이다.
array = [7,1,2,5,1,7,4]

for i in range(1, len(array)):
    for j in range(i, 0, -1):
        if(array[j] < array[j-1]):
            array[j], array[j-1] = array[j-1], array[j]
        else:
            break
            
삽입정렬은 시간복잡도는 O(N^2)으로 선택정렬과 같지만 break문이 존재한다는 점에서 선택정렬보다 빠르게 동작한다. 최대 O(N)까지 기대된다.

퀵정렬
정렬 알고리즘 중에 가장 많이 사용되는 알고리즘이다.
기준데이터를 설정하고 그 기준보다 큰 데이터와 작은 데이터의 위치를 바꾸는 방식으로 작동한다.
이때 기준을 정해야하는데 책에서는 호어 분할 방식을 기준으로 설명한다.
호어분할 방식은 리스트에서 첫 번째 데이터를 피벗(기준)으로 설정한다.
이렇게 피벗을 설정한 다음에 오름차순 기준으로 왼쪽에서(피벗보다 왼쪽이 아니라 그냥 배열상 제일 왼쪽) 피벗보다 큰 데이터를 찾고, 오른쪽에서 피벗보다 작은 데이터를 찾아서 둘을 교환해준다.
이때 왼쪽에서 시작한 데이터와 오른쪽에서 시작한 데이터가 엇갈려서 서로 오른쪽 왼쪽이 바뀔 때는 찾아진 작은데이터를 피벗인 값과 위치를 바꾼다.
지금 방법까지 완료하면 원래 피벗이 교환되어서 들어간 자리 오른쪽에는 원래 피벗보다 큰수가, 왼쪽에는 작은수가 들어가 있다.
이 상태에서 왼쪽과 오른쪽을 개별적으로 피벗을 활용해서 정리하고, 이를 반복하면 결과적으로 배열이 정리가 된다.
이를 기본적인 소스코드로 살펴보면 이해가 쉽다.

array = [5, 7, 9, 0, 3, 1, 6, 2, 4, 8]

def quick_sort(array, start, end):
        if(start >= end):
            return
        pivot = start
        left = start + 1
        right = end
        while(left <= right):
            while(left <= end and array[left] <= array[pivot]):
                left += 1
            while(right >= start and array[right] >= array[pivot]):
                right -= 1
            if( left > right ):
                array[right], array[pivot] = array[pivot], array[right]
            else:
                array[left], array[right] = arrya[right], array[left]
        quick_sort(array, start, right-1)
        quick_sort(array, right+1, end)
        
처럼 구현하면 된다. 이처럼 사람 머리로 쉽게 정리가 안되는 것이더라도 컴퓨터 알고리즘으로 풀어쓰면 쉬워보이는 코드가 많다.
그래서 알고리즘을 더 공부해야하는 한다고 생각한다.

퀵 정렬의 시간복잡도는 평균 O(NlogN)이며, 최대 O(N^2) 이다.
퀵 정렬의 데이터는 데이터가 잘 정리되어있으면 더욱 느리다. 따라서 삽입정렬 알고리즘과 선택적으로 사용해야한다.
하지만 라이브러리를 사용하면 퀵정렬을 평균 NlogN을 보장해주도록 추가적인 설정을 도와준다.

계수정렬
계수 정렬은 특정한 조건이 부합할 때 사용하는 매우 빠른 정렬 알고리즘이다.
조건은 데이터의 크기 범위가 제한되어 정수 형태로 표현할 수 있을 때만 사용할 수 있다.
또한 가장 큰 데이터와 가장 작은 데이터의 차이가 1,000,000을 넘지 않을 때 효과적으로 사용할 수 있다.
이런 조건이 생긴 이유는 계수정렬을 만들 때 모든 범위를 담을 수 있는 크기의 리스트(배열)을 선언해야하기 때문이다.
계수 정렬은 앞서 소개한 정렬처럼 데이터들끼리의 비교로 위치를 변경하는 방식의 정렬이 아니다.
일반적으로 별도의 리스트를 선언하고, 그 안에 정렬에 대한 정보를 담는다는 특징이 있다.
먼저 가장 큰 데이터와 가장 작은 데이터의 범위가 모두 담길 수 있도록 하나의 리스트를 생성한다.
0부터 9까지의 숫자로 이루어져 있다면 크기가 10인 리스트를 초기값이 0이도록 선언하면 된다.
그리고나서 원래 데이터를 돌며 값과 같은 인덱스의 값을 1씩 추가해준다. 쉽게 말해서 원래 데이터에 1이 3개있으면 새롭게 만든 리스트의 인덱스 1번의 값을 +3해주는 것이다.
결과적으로 새로 만든 리스트에는 각 데이터가 몇번 등장했는지 횟수가 기록된다.
이제부터는 인덱스를 그 값만큼 출력하면 정렬되어서 나오게 된다.
이를 코드로 표현하면 다음과 같다.

array = [7, 5, 9, 0, 3, 1, 6, 2, 9, 1, 4, 8, 0, 5, 2]
new_array = [0]*(max(array)+1)

for i in range(len(array)):
    new_array[array[i]] += 1
    
for i in range(len(new_array)):
    print(str(i)*new_array[i], end='')

계수 정렬의 시간 복잡도는 데이터의 개수를 N, 데이터 중 최대값의 크기를 K라고 했을 때, 계수 정렬의 시간 복잡도는 O(N+K)이다.
하지만 계수 정렬은 때에 따라서 심각한 비효율성을 초래할 수 있다. 예를들어서 데이터가 0과 99만 이렇게 두개만 있을 때도, 리스트를 99만 1개를 만들어야한다는 것이다.
또한 겹치는 값이 없이 그냥 다 다른 숫자라면 퀵 정렬이 빠르게 동작할 수 있다.
따라서 계수 정렬은 데이터 크기가 한정되어 있고 많이 중복되어 있을 수록 유리하다.
