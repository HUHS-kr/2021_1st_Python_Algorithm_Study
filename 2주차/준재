# Greedy Algorithm

# Greedy Algorithm의 Greedy는 탐욕을 뜻하며 Greedy Algorithm은 탐욕 알고리즘이라고 불린다.
# 어떠한 선택을 해야하는 상황을 마주하면 미래를 생각하지 않고 그 순간 가장 최적의 선택지를 선택하는 알고리즘을 그리디 알고리즘이라고 한다.

# 한번 적당한(?) 예시를 들어 생각해 보았다.
# 누군가 높이 8000m의 히말라야 산맥 한가운데에서 조난을 당했다고 하자.
# 이 사람은 핸드폰도 없고 나침반도 없어 내려오는 길을 알지 못한다.(물론 마실 물과 산소통, 음식도 없다)
# 그럼 이사람에게 주어진 탈출 방법은 크게 두 가지 방법이 있을 것이다.
1. 히말라야 산맥의 가장 높은 에베레스트에 올라가 꼭대기에서 아래를 내려 보며 탈출 경로를 생각해 본다.-> 탈출 경로를 외운다 -> 외운 경로로 내려간다
2. 그냥 자신의 위치에서 더 이상 올라가지 않고 아무 생각 없이 내려 온다.
# 1번 방법은 오히려 자신의 생존 확률을 갉아 먹는 행위일 것이다. 에베레스트를 등산하는 것은 탈출 하는 것 보다 어렵다.
# 그럼 2 번 방법을 써야 할텐데, 그냥 아무 생각 없이 내려 오면 오히려 길을 잘 못 들어 시간만 낭비하고 죽을 수도 있다.
# 이떄 아주 좋은 생각을 해냈다. 2번 방법을 써서 내려오긴 내려 올것이다.
# 하지만, 멍청하게 아무생각 없이 내려오는 것이 아니라 특정한 알고리즘을 따라 내려 올것이다.
# 알고리즘은, 한발자국 한발자국 내려 올떄마다 자신의 위치를 360도 돌며 가장 경사가 가파른 곳을 선택해서 내려오는 것이다.
# 이게 바로 그리디 알고리즘이다. 자신이 처한 상태에서 가장 좋아보이는 최적의 선택지를 선택하는 것이다.
# 그럼 자신은 항상 아래로만 내려갈 것이다.
# 근데 그리디 알고리즘에는 큰 문제점이 있다. 이 사람은 산에서 내려가긴 내려갈텐데 그게 탈출구라는 보장은 없다.
# 그냥 히말라야 산맥의 하나의 골( 마루와 골 중에 골)로 내려 가는 것일 수도 있고, 경사가 가파른 곳만 선택하다보면 탈출구는 커녕 크레바스(크레바스의 경사는 엄청 가파르다)에 빠질 수도 있다.
# 물론, 운이 좋아서 산을 탈출 할 수도 있을 것이다.


# 그러므로, 그리디 알고리즘은 빠르고 생각하기 쉽다는 장점은 있지만, 그게 항상 최적의 해를 도출해낸다는 보장이 없기 때문에 어렵기도 하다.


# 문제를 풀면서 가장 어려었던 문제 하나만 정리해보겠다.

 이것이 코딩 테스트다 pg 314 <만들수 없는 금액>
 
 # 이문제를 처음 봤을떄, target을 1부터 1 씩 더해가며 현재 가지고 있는 돈으로 target을 만들 수 있는지,모든 조합을 만들어 set()에 저장한후 일일이 비교해 보려 했다.
 # 하지만 이 방법을 쓸경우 경우 화폐의 개수가 적으면 상관없지만 조금만 많아지면 경우의 수가 exponential 커질 것이라고 예상이 갔다.
 # 또한, 이 방법을 쓸 경우 문제 접근 법이 하나도 그리디 하지 않다.
 # 그래서 아무리 생각해도 그리디를 사용해서 풀 수 없을 것 같아 답지를 봤고 해설도 봤다.(그래도 이해 하기가 어려웠다)
 
<답>
n=int(input())
data=list(map(int,input().split()))
data=sorted(data)
target=1
for x in data:
    if target< x:
        break
    target+=x
print(target)

<설명>
1. target을 이 문제에서는 "target-1 까지는 어떻게든 만들 수 있어, 그럼 target은?" 이라고 대입해서 풀어 보자.
2. n=5 이고 data =[1,1,2,3,9] 라고 했을떄 loop을 돌려보자.
3. 처음에 target을 1로 설정해 줬으므로 이제부터 target을 "0 까지는 어떻게든 만들 수 있어, 그럼 1 은?"이라고 생각하는 거다.
4. 첫번쨰 loop, x에 1 이 들어 간다. 1 하나로 만들수 있는 숫자는 1밖에 없다.
   그러므로 target에서 요구한 질문인 "1은?" 에서 1 을 만들수 있다. 성공!
5. target 값에 1을 더해주면 2가 된다.
6. 두번쨰 loop,이제 target을 " 1까지는 어떻게든 만들 수 있어, 그럼 2 는?" 이라고 할거다
7. x 에 1이 들어온다.
8. 그럼 첫번쨰 loop에서의 1과 지금 들어온 1을 합쳐서 만들 수 있는 수는 1하나로 만들 수있는 수인 1, 그리고 1 + 1 = 2 이다. 2를 만들 수 있다. 성공!
9. 세번쨰 loop,이제는 target 을 2+1인 3으로 업데이트 해주고 target을 "2 까지는 어떻게든 만들 수 있어, 그럼 3은?"이라고 생각하자
10. x에 2가 들어돈다. 
11. 앞에서 우린 1,2를 만들 수 있었다. 그럼 x에 2가 들어오면 (1,2,1+2,2+2)해서 4까지 만들 수 있다. 3을 만들 수 있으므로 성공!
12. 네번쨰 loop, 이제틑 target을 5로 업데이트 해주고 target을 "4 까지는 어떻게든 만들 수 있어, 그럼 5은?"이라고 생각하자
13.x에 3이 들어온다.
14. 우린 4까지의 모든 수를 만들 수 있다.(1,2,3,4) 여기에 3이 추가 되면 (1,2,3,4,3+1,3+2,3+3,3+4), 겹치는거 뺴면 (1,2,3,4,5,6,7) 까지의 모든 숫자를 만들 수 있다. 
     5 를 만들 수 있으므로 성공!
15. 마지막 loop, 이제는 7까지 모든 숫자를 어떻게든 만들었으므로 target을 8로 업데이트 한다. 그럼 target을 "7 까지는 어떻게든 만들 수 있어, 그럼 8은?"이라고 생각하자.
16. x에 9가 들어온다.
17. 여기서 문제가 발생한다. 만들수 있는 모든 숫자를 보자
18. (1,2,3,4,5,6,7,9,1+9,2+9,3+9,4+9,5+9,6+9,7+9) -> (1,2,3,4,5,6,7,9,10,11,12,13,14,15,16)
19. 8 이 빠졌다. 실패!! 처음으로 만들 수 없는 숫자가 나왔다.
20 8을 출력해준다.
 
 # 설명이 매끄럽지 않을 수도 있지만, 이렇게 이해하지 않으면 이해하기 어려웠다.
 
