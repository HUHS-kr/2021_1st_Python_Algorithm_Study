* 그리디(Greedy) 알고리즘: 탐욕법; 현재 상황에서 지금 당장 좋은 것만 선택
>> 사전에 풀이를 외우지 않아도 되는 문제 유형; 다익스트라(Dijkstra) 알고리즘 제외
>> 정렬 알고리즘과 자주 등장 ex) 가장 큰 순서대로, 가장 작은 순서대로, ...

- 문제 풀이를 위한 최소한의 아이디어를 떠올리고 이것이 정당한지 검토 후 답 도출


[문제 풀이]
#01 모험가 길드
Idea: 그룹을 만들기 가장 쉬운 경우를 생각해본다.
Key: 공포도가 가장 낮은 모험가부터 그룹을 만들어간다.
1. 모험가 배열을 공포도에 따라 오름차순으로 정렬한다.
2. 그룹에 속하지 않은, 공포도가 제일 작은 모험가의 공포도만큼 앞에서부터 그룹을 만든다.
3. 그룹 구성에 성공했다면 그룹 수를 +1 카운트하고 2번을 반복한다. 그룹 구성에 실패했다면 종료한다.

#02 곱하기 혹은 더하기
Idea: 일반적으로 곱셈이 덧셈보다 연산 결과가 크지만, 예외가 있다.
Key: 곱하기를 우선으로 넣되, 연산자나 피연산자 자리에 0이나 1이 있으면 더하기를 넣는다. (0이나 1의 경우 곱셈보다 덧셈이 연산 결과가 더 크다.)
1. 문자열의 첫 숫자를 저장하고, 두 번째 숫자를 검사한다.
2. 두 수 중 0이나 1이 있다면 두 수의 합을, 없다면 두 수의 곱을 저장한다.
3. 다음 숫자로 넘어가 2번을 반복한다. 문자열이 끝나면 종료한다.

#03 문자열 뒤집기
Idea: 모든 문자열을 0으로 바꿀지, 1로 바꿀지 생각해본다.
Key: 문자열의 시작과 끝을 비교해 같은 경우는 그 숫자로 모두 바꾼다.
1. 문자열의 중복되는 구간의 숫자를 하나로 간소화한다. ex) 0111000001111011 >> 010101
2. 문자열의 양 끝 숫자를 비교한다.
3-1. 같을 경우 그 숫자를 n이라고 할 때, 문자열을 왼쪽부터 읽어나가며 n이 아닌 숫자가 몇 개인지 출력한다.
3-2. 다를 경우 간소한 문자열의 길이를 2로 나눈 값을 출력한다.

#04 만들 수 없는 금액
Idea: 적은 금액부터 가능한 경우를 조합해본다.
Key: 가능한 모든 경우를 도출하고, 조합 불가능한 금액을 찾는다.
1. 동전 배열을 오름차순으로 저장한다. 목표 금액은 1원부터 시작한다.
2. 목표 금액 이하의, 최대 금액을 찾는다. ex) 목표 금액 4원일 때, [1, 2, 3, 5] 배열에서 4 이하의 최대 금액 '3'에 해당
3. 예제 3-1과 동일하게, 그 금액부터 내려가며 더하면서 목표 금액을 만들 수 있는지 검사한다.
4. 목표 금액을 만들 수 있다면 목표 금액을 +1원 늘리고 2번부터 반복한다. 만들 수 없다면 종료한다.

#05 볼링공 고르기
Idea: 정렬 후 볼링공의 무게를 비교할 때 더 쉬운 방법을 생각해본다.
Key: 두 사람이 무게가 같은 볼링공을 고르는 경우를 생각해본다.
1. 볼링공 배열을 정렬한다.
2. 배열의 요소를 확인하면서 무게 별 볼링공의 개수를 저장한다.
3. 각 무게의 볼링공 수 - 1 을 cnt에 더한다.
4. (조합) NC2 - cnt 을 출력한다.

#06 무지의 먹방 라이브
Idea: 어떤 음식을 다 먹기 전까지는 먹는 순서에 변화가 생기지 않는다.
Key: 가장 적게 남은 음식을 찾아 그 음식을 먹는 데 걸리는 시간만큼 과정을 단축한다.
1. 모든 음식을 먹는 시간을 합산하여 K보다 같거나 작다면 -1을 출력하고 종료한다.
2. 가장 적게 남은 음식을 찾는다.
3. K에서 (그 음식을 먹는 데 걸리는 시간 * 남은 음식의 종류 수) 만큼을 뺀다.
3-1. K가 그 보다 작다면 대신 K+1를 출력하고 종료한다.
4. 그 음식을 먹는 데 걸리는 시간만큼, 각 음식을 먹는 데 걸리는 시간을 감소시킨다.
5. 2번부터 반복한다.
