다이나믹 프로그래밍: 메모리 공간을 약간 더 사용해서 연산 속도를 비약적으로 증가시킴.
한 번 해결된 부분 문제의 정답을 메모리에 기록하여, 한 번 계산한 답은 다시 계산하지 않도록 하는 문제 해결 기법이다.
다이나믹 프로그래밍은 점화식을 그대로 코드로 옮겨서 구현할 수 있다.

다이나믹 프로그래밍을 사용할 수 있는 조건)
1. 큰 문제를 작은 문제로 나눌 수 있다.
2. 작은 문제에서 구한 정답은 그것을 포함하는 큰 문제에서도 동일하다.

탑다운 방식 vs 보텀업 방식
탑다운 방식: 큰 문제를 작게 나누고, 같은 문제라면 한 번씩만 풀어 문제를 효율적으로 해결하는 알고리즘 기법.
한 번 푼 문제는 결과를 저장해 놓았다가 나중에 동일한 문제를 풀어야 할 때 이미 저장한 값을 반환함.
보텀업 방식: 반복문을 이용하여 작은 문제부터 차근차근 답을 도출하는 방식.

예시) 피보나치 수열 소스코드 (탑다운 방식, 재귀함수 이용)
d = [0]*100
def fibo(x):
    if x == 1 or x == 2:
        return 1
    if d[x] !=0:
        return d[x]
    else:
        d[x]=fibo(x-1)+fibo(x-2)
        return d[x]
print(fibo(99))

예시) 피보나치 수열 소스코드(보텀업 방식, 반복함수 이용)
d=[0]*100

d[1]=1
d[2]=1
n=99 #알고자 하는 수의 index

for i in range(3, n+1):
    d[i] = d[i-2]+ d[i-1]
print(d[n])

실전문제 1. 1로 만들기
d[x]: 입력값 x의 호출횟수
d[i]=min(d[i-1],d[i//2],d[i//3],d[i//5])+1

소스코드)
x = int(input())
d = [0] * 30001
for i in range(2,x+1):
    d[i]=d[i-1]+1
    if i%2 == 0:
        d[i] = min(d[i],d[i//2]+1)
    if i%3 == 0:
        d[i] = min(d[i],d[i//3]+1)
    if i%5 == 0:
        d[i] = min(d[i],d[i//5]+1)
#5로 나누어 떨어지는 경우가 가장 우선시되어야 하기 때문에(최소 횟수) 가장 밑에 배치한다.
print(d[x])

실전문제2. 개미 전사
d[i]=max(d[i-1],d[i-2]+array[i])

실전문제3. 바닥 공사
d[i]=(d[i-1]+2*d[i-2])

기출문제1. 금광
n*m크기의 dp테이블을 만든 다음, 왼쪽 위, 왼쪽 아래, 왼쪽의 수 중에 가장 큰 수를 특정 dp[i][j]위치에 더해지도록 코드를 짜고, 열마다 업데이트 시켜 끝 열까지 반복시킨다.
그 후, 마지막 열의 수를 비교하여 가장 큰 수를 결과로 반환한다.

기출문제2. 정수 삼각형
왼쪽 위, 바로 위의 수 중 큰 수를 현재 위치에 더해지도록 반복문을 이용해 코드를 짠다. 마지막 열의 수 중 가장 큰 수를 결과로 반환한다.

기출문제3. 퇴사
t[i]: i번째 날의 상담을 완료하는 데 걸리는 기간
p[i]: i번쨰 날의 상담을 했을 때 받을 수 있는 금액
매 상담에 대하여 현재 상담 일자의 이윤(p[i])+상담을 마친 일자부터의 최대 이윤(dp[t[i]+i])를 계산한다.
dp[i]=max(p[i]+dp[time], max_value)
max_value = dp[i]
이 때, 마지막 날부터 반복을 시작해야 i번째 날의 상담을 했을 경우와 안했을 경우의 max값을 비교할 수 있다.
따라서, 마지막 날인 n-1부터 -1하며 반복시킨다.

기출문제4. 병사 배치하기
n: 병사 수
i: n명 중 i번째 병사
j: 0~i번째 병사까지 반복문 수행
for i in range(1,n):
    for j in range(0,i)
j와 i번째 병사의 전투력을 비교하며, 더 큰 수를 dp[i]에 업데이트한다. dp수열 중 가장 큰 수가 병사의 최대 수이다.
따라서 열외시켜야 하는 병사의 최소 수는 n-max(dp)이다.

기출문제5. 못생긴 수
next2, next3, next5변수에 각각 2의 배수,3의 배수,5의 배수를 업데이트한다.
이때 next2, next3, next5변수에 곱해지는 값도 못생긴 수이다.
반복문을 이용해 next2, next3, next5값을 비교하며 최소인 수를 ugly[l]에 업데이트한다.
ugly[l]=min(next2, next3, next5)
n번째 못생긴 수를 구하려면 1~n-1번 반복하고, ugly[n-1]이 결과값이다.

기출문제6. 편집 거리
문자열 A를 행, 문자열 B를 열로 하는 2차원 테이블을 만들고, 행과 열에 해당하는 문자를 서로 비교한다.
행과 열의 문자가 같으면, 왼쪽 위에 해당하는 수를 그대로 대입한다.
dp[i][j]=dp[i-1][j-1]
행과 열의 문자가 다르면, 왼쪽(삽입), 위쪽(삭제), 왼쪽 위(교체)에 해당하는 수 중 가장 작은 수에 1을 더해 대입한다.
dp[i][j]=1+min(dp[i][j-1],dp[i-1][j],dp[i-1][j-1])




