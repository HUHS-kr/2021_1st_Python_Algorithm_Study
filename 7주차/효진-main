다이나믹 프로그래밍: 메모리 공간을 약간 더 사용해서 연산 속도를 비약적으로 증가시킴.
다이나믹 프로그래밍을 사용할 수 있는 조건)
1. 큰 문제를 작은 문제로 나눌 수 있다.
2. 작은 문제에서 구한 정답은 그것을 포함하는 큰 문제에서도 동일하다.

탑다운 방식 vs 보텀업 방식
탑다운 방식: 큰 문제를 작게 나누고, 같은 문제라면 한 번씩만 풀어 문제를 효율적으로 해결하는 알고리즘 기법.
한 번 푼 문제는 결과를 저장해 놓았다가 나중에 동일한 문제를 풀어야 할 때 이미 저장한 값을 반환함.
보텀업 방식: 반복문을 이용하여 작은 문제부터 차근차근 답을 도출하는 방식.

예시) 피보나치 수열 소스코드 (탑다운 방식, 재귀함수 이용)
d = [0]*100
def fibo(x):
    if x == 1 or x == 2:
        return 1
    if d[x] !=0:
        return d[x]
    else:
        d[x]=fibo(x-1)+fibo(x-2)
        return d[x]
print(fibo(99))

예시) 피보나치 수열 소스코드(보텀업 방식, 반복함수 이용)
d=[0]*100

d[1]=1
d[2]=1
n=99 #알고자 하는 수의 index

for i in range(3, n+1):
    d[i] = d[i-2]+ d[i-1]
print(d[n])

실전문제 1. 1로 만들기
d[x]: 입력값 x의 호출횟수
d[i]=min(d[i-1],d[i//2],d[i//3],d[i//5])+1

소스코드)
x = int(input())
d = [0] * 30001
for i in range(2,x+1):
    d[i]=d[i-1]+1
    if i%2 == 0:
        d[i] = min(d[i],d[i//2]+1)
    if i%3 == 0:
        d[i] = min(d[i],d[i//3]+1)
    if i%5 == 0:
        d[i] = min(d[i],d[i//5]+1)
print(d[x])

실전문제2. 개미 전사
d[i]=max(d[i-1],d[i-2]+array[i])

실전문제3. 바닥 공사
d[i]=(d[i-1]+2*d[i-2])

실전문제4. 효율적인 화폐 구성
