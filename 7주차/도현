어떤 문제는 메모리 공간을 약간 더 사용하면 연산 속도를 비약적으로 증가시킬 수 있는 방법이 있다.
대표적인 방법이 이번 장에서 다루는 다이나믹 프로그래밍기법으로 동적계획법이라고 표현하기도 한다.

피보나치 수열처럼 수학적 점화식으로 표현할 수 있는 방법은 재귀함수를 사용하면 간단하다.
하지만 재귀함수를 사용하는 방법은 n이 커질수록 기하급수적으로 증가하는 O(2^N)의 시간복잡도를 가지고 있다.
따라서 이 문제에서는 다이나믹프로그래밍을 사용하는 것이 좋다.
다이나믹 프로그래밍의 사용조건은 다음과 같다.
1.큰 문제를 작은 문제로 나눌 수 있다.
2.작은 문제에서 구한 정답은 그것을 포함하는 큰 문제에서도 동일하다.

피보나치 수열은 이를 만족하는 문제이고 다이나믹프로그래밍의 기법인 메모이제이션(Memoization)기법을 사용해서 해결할 수 있다.
이를 구현하는 것은 직관적으로 어렵지 않다. 한 번 구한 정보를 리스트에 저장해놓고, 다시 필요하다면 리스트에서 가져오면 되는 것이다.

memo = [0]*100 # 한번 사용된 것을 넣을 리스트 생성

def fibo(x):
    if x==1 or x==2:
        return 1 #만약 x가 1이나 2라면(첫번째 두번째라면) 1을 반환
    if memo[x] != 0: #중복된 것은 그냥 계산없이 리스트에 있는거 가져와서 사용
        return memo[x]

    memo[x] = fibo(x-1) + fibo(x-2) #f(x)의 값들을 저장
    return memo[x]

이렇게 중복된 것을 계산하지 않았을 때의 시간 복잡도는 O(N)으로 획기적으로 줄어들었다는 것을 알 수 있다.
이처럼 점화식을 이용한 재귀함수를 사용해서 다이나믹 프로그래밍을 하는 방법을 탑다운 방식이라고 말한다. 큰 문제를 해결하기 위해 작은 문제를 호출한다는 뜻이다.
단순 반복문을 사용해서 차근차근 올라가는 방법을 보텀업 방식이라고 한다. 이전의 피보나치 수열을 보텀업으로 수행하면 다음과 같다


memo = [0]*100 # 한번 사용된 것을 넣을 리스트 생성

memo[1] = 1
memo[2] = 1

for i in range(3,100):
    memo[i] = memo[i-1] + memo[i-2]

이때는 그냥 memo[99] 가 fibo(99)와 같다.
이는 다이나믹 프로그래밍의 전형적인 형태이며 다이나믹은 보편적으로 보텀업 형태를 취한다. memo처럼 보텀업 방식에서 사용되는 결과 저장용 리스트는 'DP 테이블'이라고 부르며,
메모이제이션은 탑다운 방식에 국한되어 사용되는 표현이다.
그러니까 정리하면 탑다운 방식은 재귀함수를 사용하며, 메모이제이션이라는 기법을 사용한다.
보텀업 방식은 다이나믹프로그래밍의 보편적인 형식이며, 단순 반복문을 사용하며 DP 테이블에 결과를 저장한다.

다이나믹 문제를 풀기위해서는 우선 중복여부로 인한 복잡도 상승을 파악해야한다.


