'Binary search' is an algorithm for searching through elements of a presorted array.

순차탐색 알고리즘은 리스트 내에서 데이터를 탐색하는 기본적인 방법이다.
앞에서부터 데이터를 하나씩 차례대로 확인하는 방법으로 보통 정렬되지 않은 리스트에서 데이터를 찾아야할 때 사용한다.
구현은 다음과 같다.
def sequential_search(n, target, array):
    for i in range(n):
        if array[i] == target:
            return i+1
으로 매우 간단하게 for문을 통해 O(N)의 시간 복잡도로 확인할 수 있다.

이진탐색 알고리즘은 내부의 데이터가 정렬되어 있었을 때 사용하는 알고리즘이다.
데이터가 정렬되어있지 않을 때는 사용할 수 없지만 정렬만 되어 있다면 매우 빠른속도로 탐색을 할 수 있다.
시작점, 끝점, 중간점을 통해 탐색을 진행하며 중간점의 데이터와 찾으려는 데이터를 비교하며 탐색하는 과정이다.
쉽게 설명하면, 반씩 잘라가면서 보다 큰지 보다 작은지로 범위를 좁혀가는 방법이다.
구현은 다음과 같다.
def binary_search(array, target, start, end):
    while start <= end:
        mid = (start + end)//2
        if array[min] == target:
            return mid
        elif array[mid] > target:
            return binary_search(array, target, start, mid-1)
        else:
            return binary_search(array, target, mid+1, end)
            
이렇게 계속해서 중간점을 찾아내며 탐색을 지속한다.
이진탐색의 시간 복잡도는 O(logN)이다.

이렇게보면 이진탐색은 매우 간단해보이지만 존 벤틀리의 말에 따르면 제대로 이진 탐색코드를 작성하는 프로그래머는 10%내외라고 할 정도로 구현이 까다로운 알고리즘이다.
하지만 코딩테스트에서 단골로 나오는 문제이니 가급적 외우길 추천한다.

데이터베이스는 기본적으로 데이터처리에 적합한 트리 자료구조를 이용하여 항상 데이터가 정렬되어 있다. 
따라서 데이터베이스에서의 탐색은 이진 탐색과 조금 다르지만 비슷하게 빠른 속도로 탐색할 수 있다.

연습문제 1. 부품 찾기
N개의 부품에 고유번호가 적혀있다.
M개 종류의 부품을 대량으로 구매해야해서 모두 확인해야한다. 모두 확인하는 프로그램 작성.
이런 프로그램은 비교적 간단하다고 할 수 있다. 왜냐하면 고유번호가 있고, 그것을 순서대로 정렬한 후
이진 탐색을 통해 모두 확인해볼 수 있기 때문이다.

연습문제 2.떡볶이 떡 만들기
길이가 일정하지 않은 떡볶이 떡을 만드는데 한 봉지 단위의 떡의 총 길이는 일정하다.
손님이 왔을 때 요청한 총 길이가  M일 때 적어도 M만큼의 떡을 얻기 위해 절단기에 설정하는 높이의 최댓값을 구하라.
파라메트릭 서치 유형의 문제이다. 최적화 문제를 -> 결정문제로 바꾸어 해결하는 기법으로, '원하는 조건을 만족하는 가장 알맞은 값을 찾는 문제'이다.
예를 들어 필요한 떡의 길이가 6cm이고 떡의 높이가 19, 15, 10, 17cm이면 절단기의 높이는 0부터 19까지로 설정한 후 이진탐색을 진행하며
조건을 만족하는 값을 구해나가면 된다.

기출문제 1.정렬된 배열에서 특정 수의 개수 구하기.
정렬되어있는 수열에서 하나의 값이 등장하는 개수를 출력하면 된다.
단 시간복잡도 O(logN)로 설계해야한다.
이 문제는 시간복잡도를 고려했을 때 선형탐색이 아닌 이진 탐색으로 풀어야한다.
또한 정렬되어있는 수열이라는 조건을 고려했을 때 역시 이진탐색이 적당한 풀이 방법임을 도출할 수 있다.
이때 개수에 대한 문제이므로 첫번째 인덱스와 마지막 인덱스를 찾아야 하는데,
이는 이진탐색을 두번 사용해서 구할 수 있다.
또한 이 문제는 정렬되어있는 데이터에서 특정 값을 찾는 문제로 해석 가능하므로
파이썬의 bisect에서 bisect_right, bisect_left를 사용하면 코드를 더욱 깔끔하게 구현할 수 있다.

기출문제 2.고정점 찾기
값이 인덱스번호와 같은 점을 고정점이라고 한다. 이때 고정점은 최대 1개 존재하며
존재하지 않는다면 -1를 반환한다. 또한 모든 원소가 오름차순으로 정렬되어있다.
이 문제역시 시간복잡도 O(logN)으로 설계해야한다.
정렬되어있는 데이터에서 시간복잡도 O(logN)으로 설계하는 탐색은 이진 탐색을 사용한다.
이는 간단하게 재귀함수로 구현할 수 있고 어렵지 않은 문제라고 생각된다.

기출문제 3.공유기 설치
집 N개가 수직선 위에 존재하고, 공유기 C개를 설치하고자 하는데 최대한 많은 곳으로 와이파이를 사용하게( 최적화 ) 두 공유기 사이의 거리를 가능한 크게 설치하려고 한다.
C개의 공유기를 N개의 집에 최적화해서 설치하는 프로그램 작성.
인접한 거리가 최대가 되게하는 조건을 가지는 파라메트릭 서치 유형의 문제이다.
먼저 좌표가 정렬되어있다는 말이 없으니, 정렬을 간단하게 sort를 이용해 진행하고,
수직선위에 존재하는 좌표로 시작점과 끝점을 설정한다.
그리고 공유기 사이의 거리를 중간점으로 생각한 후 이진 탐색을 진행하는데, 
여기서도 왼쪽 오른쪽 개념을 사용하여 공유기 설치 개수를 C개를 기준으로 이상과 이하에 대해 거리를 증가시키거나 감소시켜서
최적의 거리를 구하는 것이 중요한 문제이다.
여기서 알아가야할 중요한 점은 이러한 유형이 흔하고 형식적이라는 것이다.
문제를 보고 생각해보면, 만족하는 조건을 맞추게 만드는 것을 탐색을 통해 찾아보라는 문제임을 쉽게 알 수 있다.
우리는 이진탐색을 통한 파라메트릭 서치를 배운 입장으로, 이 문제를 조건문에 대한 문제보다 이진 탐색에 대한 문제로 여길 수 있으면 된다.

기출문제 4.가사검색
난이도에서도 나와있지만 쉽지않은 문제이다. 하지만 사실 이것이 이진탐색 문제라는 것을 인식한다면 코드를 짜내는 것은 어렵지 않을 것이고
상위 기업의 코딩테스트를 위해서 충분하게 넘어설 수 있어야 한다.
문제를 쉽게 설명하면 노래가사에 사용된 단어들 중에 특정 키워드가 몇개 포함되어 있는지 알아내는 프로그램을 작성하는 것이다.
아까 2번문제처럼 탐색 후 개수를 찾아내는 방법을 사용하면 된다.
파이썬에는 다행이 데이터를 다루는 라이브러리가 아주 많은 편이고, 그로인해 진행해야하는 몇가지 과정이 깔끔한 코드로 작성할 수 있다.
예를들어 이 문제는 정렬, 쿼리분해, String 일치확인, 대체, 첨가 등의 데이터를 다듬는 과정이 필요하고, 그렇기 때문에 쉽게 작성해내기 어려운 문제이다.
하지만 파이썬을 통한다면 bisect로 이진탐색을, append, sort, replace등을 통해 추가조작이 간편해진다.
이 문제와 비슷한 유형의 문제는 프로그래머스나, 백준, LeetCode등의 알고리즘 문제에서, 아니면 실제 코딩테스트에서 쉽게 접할 수 있는 문제이니
만약에 이번 장에서 하나의 문제는 꼭 알아가야한다면 이 문제라고 생각한다.
